<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rate Limiting Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .rapid-click {
            background: #dc3545;
        }
        .rapid-click:hover {
            background: #c82333;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Rate Limiting & Request Queue Test</h1>
        <p>This page tests the new rate limiting system to prevent 429 errors.</p>
        
        <div class="test-section">
            <h3>Test 1: Normal Request</h3>
            <button onclick="testSingleRequest()">Send Single Request</button>
            <div id="single-status"></div>
        </div>

        <div class="test-section">
            <h3>Test 2: Rapid Clicking (Old Behavior Simulation)</h3>
            <p>Click this button rapidly multiple times to simulate the old problematic behavior:</p>
            <button class="rapid-click" onclick="testRapidRequests()">Rapid Click Test (10 requests)</button>
            <div id="rapid-status"></div>
        </div>

        <div class="test-section">
            <h3>Test 3: Batched Updates Simulation</h3>
            <p>Simulate kill count updates with batching:</p>
            <button onclick="testBatchedUpdates()">Test Batched Kill Updates</button>
            <div id="batch-status"></div>
        </div>

        <div class="test-section">
            <h3>Request Log</h3>
            <button onclick="clearLog()">Clear Log</button>
            <div id="request-log" class="log"></div>
        </div>
    </div>

    <script>
        // Simple mock of our request queue system
        class MockRequestQueue {
            constructor() {
                this.queue = [];
                this.isProcessing = false;
                this.maxConcurrent = 3;
                this.delayBetweenRequests = 100;
                this.activeRequests = 0;
            }

            async add(requestFn) {
                return new Promise((resolve, reject) => {
                    this.queue.push(async () => {
                        try {
                            const result = await requestFn();
                            resolve(result);
                        } catch (error) {
                            reject(error);
                        }
                    });
                    
                    this.processQueue();
                });
            }

            async processQueue() {
                if (this.isProcessing || this.activeRequests >= this.maxConcurrent) {
                    return;
                }

                this.isProcessing = true;

                while (this.queue.length > 0 && this.activeRequests < this.maxConcurrent) {
                    const request = this.queue.shift();
                    if (request) {
                        this.activeRequests++;
                        
                        setTimeout(async () => {
                            try {
                                await request();
                            } catch (error) {
                                console.error('Request failed:', error);
                            } finally {
                                this.activeRequests--;
                                this.processQueue();
                            }
                        }, this.delayBetweenRequests);
                    }
                }

                this.isProcessing = false;
            }

            getStatus() {
                return {
                    pending: this.queue.length,
                    active: this.activeRequests,
                    isProcessing: this.isProcessing
                };
            }
        }

        class MockUpdateBatcher {
            constructor(delay = 300, accumulator) {
                this.pendingUpdates = new Map();
                this.timeouts = new Map();
                this.callbacks = new Map();
                this.delay = delay;
                this.accumulator = accumulator;
            }

            batch(key, update, callback) {
                const existingTimeout = this.timeouts.get(key);
                if (existingTimeout) {
                    clearTimeout(existingTimeout);
                }

                const existingUpdate = this.pendingUpdates.get(key);
                const finalUpdate = existingUpdate && this.accumulator 
                    ? this.accumulator(existingUpdate, update)
                    : update;
                
                this.pendingUpdates.set(key, finalUpdate);
                this.callbacks.set(key, callback);

                const timeout = setTimeout(async () => {
                    const batchedUpdate = this.pendingUpdates.get(key);
                    const storedCallback = this.callbacks.get(key);
                    
                    if (batchedUpdate && storedCallback) {
                        this.pendingUpdates.delete(key);
                        this.timeouts.delete(key);
                        this.callbacks.delete(key);
                        
                        try {
                            await requestQueue.add(() => storedCallback(batchedUpdate));
                        } catch (error) {
                            console.error('Batched update failed:', error);
                        }
                    }
                }, this.delay);

                this.timeouts.set(key, timeout);
            }
        }

        // Initialize mock systems
        const requestQueue = new MockRequestQueue();
        const killUpdateBatcher = new MockUpdateBatcher(200, (existing, newUpdate) => ({
            change: existing.change + newUpdate.change
        }));

        // Mock API function
        async function mockApiRequest(endpoint, data) {
            const startTime = Date.now();
            log(`üöÄ Starting request to ${endpoint}`, 'info');
            
            // Simulate network delay
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 100));
            
            const endTime = Date.now();
            log(`‚úÖ Request to ${endpoint} completed in ${endTime - startTime}ms`, 'success');
            
            return { success: true, data, endpoint, duration: endTime - startTime };
        }

        function log(message, type = 'info') {
            const logDiv = document.getElementById('request-log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'success' ? 'success' : type === 'error' ? 'error' : 'info';
            
            logDiv.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function clearLog() {
            document.getElementById('request-log').innerHTML = '';
        }

        async function testSingleRequest() {
            updateStatus('single-status', 'Sending single request...', 'info');
            
            try {
                const result = await requestQueue.add(() => 
                    mockApiRequest('/api/test-single', { test: 'single' })
                );
                updateStatus('single-status', `‚úÖ Single request completed successfully!`, 'success');
            } catch (error) {
                updateStatus('single-status', `‚ùå Single request failed: ${error.message}`, 'error');
            }
        }

        async function testRapidRequests() {
            updateStatus('rapid-status', 'Sending 10 rapid requests...', 'info');
            
            const promises = [];
            for (let i = 0; i < 10; i++) {
                promises.push(
                    requestQueue.add(() => 
                        mockApiRequest(`/api/rapid-${i}`, { requestId: i })
                    )
                );
            }

            try {
                const results = await Promise.all(promises);
                updateStatus('rapid-status', `‚úÖ All ${results.length} rapid requests completed successfully! No 429 errors.`, 'success');
                
                const status = requestQueue.getStatus();
                log(`üìä Queue status: ${status.pending} pending, ${status.active} active`, 'info');
            } catch (error) {
                updateStatus('rapid-status', `‚ùå Rapid requests failed: ${error.message}`, 'error');
            }
        }

        async function testBatchedUpdates() {
            updateStatus('batch-status', 'Testing batched kill count updates...', 'info');
            
            // Simulate rapid kill count changes
            const playerKey = 'team0-player0';
            let totalChanges = 0;

            // Simulate clicking + button rapidly
            for (let i = 0; i < 5; i++) {
                const change = 1;
                totalChanges += change;
                
                killUpdateBatcher.batch(
                    playerKey,
                    { change },
                    async (batchedUpdate) => {
                        log(`üéØ Batched kill update: ${batchedUpdate.change} kills for ${playerKey}`, 'success');
                        return await mockApiRequest('/api/player/stats', { 
                            killNumChange: batchedUpdate.change,
                            playerKey 
                        });
                    }
                );
            }

            // Simulate clicking - button rapidly
            for (let i = 0; i < 2; i++) {
                const change = -1;
                totalChanges += change;
                
                killUpdateBatcher.batch(
                    playerKey,
                    { change },
                    async (batchedUpdate) => {
                        log(`üéØ Batched kill update: ${batchedUpdate.change} kills for ${playerKey}`, 'success');
                        return await mockApiRequest('/api/player/stats', { 
                            killNumChange: batchedUpdate.change,
                            playerKey 
                        });
                    }
                );
            }

            updateStatus('batch-status', `‚úÖ Batched ${totalChanges > 0 ? '+' : ''}${totalChanges} kill changes. Check log for batched result.`, 'success');
        }

        // Initialize page
        log('üîß Rate limiting test page initialized', 'info');
        log('üìù This page simulates the new request queue and batching system', 'info');
    </script>
</body>
</html>
